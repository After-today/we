---
title: "linear regerssion"
author: "clq"
date: "2018年9月22日"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.


##2 线性回归

###2.1 简单线性回归

```{r warning=FALSE , message=FALSE}
#Boston数据集在MASS包里面
library(MASS)
#fix(Boston)  #看一下Boston是一张怎样的数据表
#names(Boston)#看一下Boston数据表中的各个变量名称

#用lm.fit2.1 <-lm(medv ~ lstat, data = Boston)可以得到跟以下两句同样的结果
attach(Boston)
lm.fit2.1 <- lm(medv ~ lstat) #得到线性回归函数

lm.fit2.1 #系数
summary(lm.fit2.1) #查看置信区间，p值，标准误，R^2，F统计量
```

**结果解读：**星号个数表示显著性的强弱，“*”越多表示显著性越强

```{r warning=FALSE}
confint(lm.fit2.1) #得到系数估计值的置信区间
predict(lm.fit2.1, data.frame(lstat = (c(2, 6, 9))), interval = "confidence") #用lstat预测medv得到的置信区间
predict(lm.fit2.1, data.frame(lstat = (c(2, 6, 9))), interval = "prediction") #用lstat预测medv得到的预测区间

#画出函数拟合图
plot(lstat, medv, col="blue")
abline(lm.fit2.1, lwd = 3, col = "red")

```

**注意：**lm（应变量~自变量），plot（自变量，应变量），abline()不能单独使用，上面必有一行画图的命令


###2.2 多元线性回归


```{r warning=F}
lm.fit2.2.1 <- lm(medv ~ lstat + age, data = Boston) #medv关于lstat和age的回归模型
summary(lm.fit2.2.1)
lm.fit2.2.2 <- lm(medv ~ ., data = Boston) #medv关于所有变量的回归模型
summary(lm.fit2.2.2)
lm.fit2.2.3 <- lm(medv ~ . - age, data = Boston) #medv关于除了age以外的所有变量的回归模型
summary(lm.fit2.2.3)
#用summary(lm(medv ~ lstat + age + lstat : age, data = Boston))可以得到跟以下语句一样的结果
summary(lm(medv ~ lstat+age, data = Boston)) #包含了lstat，age和lstat与age的交互项

#如果要把二次项引入线性回归 ，要用I()，不能用lstat^2， 因为 "^" 表示交互项达到某一个次数，或者用下面的函数
lm.fit2.2.4 <- lm(medv ~ poly(lstat, 5)) #把lstat的一阶二阶至五阶全部写进去了
summary(lm.fit2.2.4)

```
**注意：**如果自变量里面有定性变量，R会自动创建虚拟变量

###2.3 选择“最佳模型”

选择最佳模型跟自变量的选取可以放在一起，选择最佳模型是对已有模型去进行比较，然后选自变量相当于是还在建模，但都有关于要不要把某一个自变量引进来的问题

但是一个模型好不好，主要看拟合的怎么样或者预测能力如何，根据模型不同的用途有不同的标准，以及可能会出现某两个检测方法得出不同结论的情况，这个需要从R^2等多种信息量准则去综合判断

**方法1：anova检验**（这个函数可以比较两个嵌套模型的拟合优度）（（必须要是**嵌套模型**））

```{r , echo=TRUE,warning=FALSE}
#以下比较模型2.2.3与2.2.2
anova(lm.fit2.2.3, lm.fit2.2.2)

```
**结果解读：**这里第一个模型嵌套在第二个模型中，结果显示，p值为0.96，意味着检验不显著，即不拒绝原假设，也就是不需要把age引入线性模型中。

**方法2：用赤池信息量准则（AIC）**((寻找可以最好地解释数据但包含最少自由参数的模型))(((没有嵌套模型的要求)))

```{r,echo=TRUE}
AIC(lm.fit2.2.3, lm.fit2.2.2)

```

**结果解读：**这里表明lm.fit2.2.3更好，跟上面用ANOVA的结果一样

通过变量选择从大量的候选变量里面得到最终的自变量（较为流行以下两种）（（CH6的内容，下次再说））

**方法3：逐步回归法**（未展开）

**方法4：全子集回归**（未展开）

---
```

